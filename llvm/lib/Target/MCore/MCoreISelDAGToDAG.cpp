//===-- MCoreISelDAGToDAG.cpp - A dag to dag inst selector for MCore ------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the MCore target.
//
//===----------------------------------------------------------------------===//

#include "MCore.h"
#include "MCoreTargetMachine.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAG.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/CodeGen/TargetLowering.h"
#include "llvm/IR/CallingConv.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/KnownBits.h"
#include "llvm/Support/MathExtras.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

#define DEBUG_TYPE "mcore-dag2dag"

/// MCoreDAGToDAGISel - MCore specific code to select MCore machine
/// instructions for SelectionDAG operations.
///
namespace {
class MCoreDAGToDAGISel : public SelectionDAGISel {
public:
  MCoreDAGToDAGISel(MCoreTargetMachine &TM, CodeGenOpt::Level OptLevel)
      : SelectionDAGISel(TM, OptLevel) {}

  void Select(SDNode *N) override;

  StringRef getPassName() const override {
    return "MCore DAG->DAG Pattern Instruction Selection";
  }

  // Return a target constant with the specified value, of type i32
  inline SDValue getI32Imm(unsigned Imm, const SDLoc &dl) {
    return CurDAG->getTargetConstant(Imm, dl, MVT::i32);
  }

  // Complex Pattern Selectors.
  bool SelectAddrB(SDValue Addr, SDValue &Base, SDValue &Offset);
  bool SelectAddrH(SDValue Addr, SDValue &Base, SDValue &Offset);
  bool SelectAddrW(SDValue Addr, SDValue &Base, SDValue &Offset);
  bool SelectAddr(SDValue Addr, SDValue &Base, SDValue &Offset, unsigned scale);

private:
  bool SelectAddCarry(SDNode *N);
  bool SelectSubCarry(SDNode *N);
  bool tryConstant(SDNode *N);
  bool trySEX(SDNode *N);
  // Include the pieces autogenerated from the target description.
#include "MCoreGenDAGISel.inc"

};

}  // end anonymous namespace

/// This pass converts a legalized DAG into a MCore-specific DAG, ready for
/// instruction scheduling.
FunctionPass *llvm::createMCoreISelDag(MCoreTargetMachine &TM,
                                     CodeGenOpt::Level OptLevel) {
  return new MCoreDAGToDAGISel(TM, OptLevel);
}


static bool isIntImmediate(SDNode *N, uint32_t &Imm) {
  if (const ConstantSDNode *C = dyn_cast<const ConstantSDNode>(N)) {
    Imm = C->getZExtValue();
    return true;
  }
  return false;
}

// isOpcWithIntImmediate - This method tests to see if the node is a specific
// opcode and that it has a immediate integer right operand.
// If so Imm will receive the value.
static bool isOpcWithIntImmediate(const SDNode *N, unsigned Opc, uint32_t &Imm) {
  return N->getOpcode() == Opc
         && isIntImmediate(N->getOperand(1).getNode(), Imm);
}

/*
// InstructionSelectBasicBlock - This callback is invoked by
// SelectionDAGISel when it has created a SelectionDAG for us to codegen.
void MCoreDAGToDAGISel::
InstructionSelectBasicBlock(SelectionDAG &DAG) {
cerr << "Enter MCoreDAGToDAGISel::InstructionSelectBasicBlock\n";

  DAG.setRoot(SelectRoot(DAG.getRoot()));
  DEBUG(DAG.dump());
  DAG.RemoveDeadNodes();

  ScheduleAndEmitDAG(DAG);
cerr << "Exit  MCoreDAGToDAGISel::InstructionSelectBasicBlock\n";
}
*/

bool MCoreDAGToDAGISel::SelectAddr(SDValue N,
	    SDValue &Base, SDValue &Offset, unsigned Scale)
{
LLVM_DEBUG(dbgs() << "MCoreDAGToDAGISel::SelectAddr("
     << N.getNode()->getOperationName(CurDAG) << ")\n");
  SDLoc dl(N);

  switch (N.getOpcode()) {
  case MCoreISD::GA: {
LLVM_DEBUG(dbgs() << "\tGA wrapper\n");
      SDValue GA = N->getOperand(0);
      SDNode *T = CurDAG->getMachineNode(MCore::LRW, dl, MVT::i32, GA);
      Base = SDValue(T, 0);
      Offset = getI32Imm(0, dl);
      return true;
    }
  case ISD::FrameIndex:
LLVM_DEBUG(dbgs() << "\tFrameIndex\n");
    if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(N)) {
      Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
      Offset = getI32Imm(0, dl);
      return true;
    }
    break;
  case ISD::ADD:
    // ADD => base + displacement
    if (ConstantSDNode *RHS = dyn_cast<ConstantSDNode>(N.getOperand(1))) {
      int n = RHS->getSExtValue();
LLVM_DEBUG(dbgs() << "\tAdd constant=" << n << " scale=" << Scale << '\n');
      int RHSC = n / Scale;
      if (RHSC >= 0 && RHSC < 16) {
        Base = N.getOperand(0);
	Offset = getI32Imm(n, dl);
	return true;
      }
    }
    // not a single instruction result
    Base = N;
    Offset = getI32Imm(0, dl);
    return true;
    break;
  default:
LLVM_DEBUG(dbgs() << "\tAssume just a register\n");
    Base = N;
    Offset = getI32Imm(0, dl);
    return true;
  }
  return false;
}

bool MCoreDAGToDAGISel::SelectAddrB(SDValue Addr,
		    SDValue &Base, SDValue &Offset) {
  return SelectAddr(Addr, Base, Offset, 1);
}

bool MCoreDAGToDAGISel::SelectAddrH(SDValue Addr,
		    SDValue &Base, SDValue &Offset) {
  return SelectAddr(Addr, Base, Offset, 2);
}

bool MCoreDAGToDAGISel::SelectAddrW(SDValue Addr,
		    SDValue &Base, SDValue &Offset) {
  return SelectAddr(Addr, Base, Offset, 4);
}

static unsigned
CountLeadingZeros(uint32_t x)
{   unsigned n;
    n = 32;
    while (x != 0)
    {   x >>= 1;
        n--;
    }
    return n;
}

static bool
FindConst1(uint32_t n, unsigned &inst, uint32_t &valu)
{
    if (n <= 127)
    {   inst = MCore::MOVi;
        valu = n;
	return true;
    }
    if ((n & (n-1)) == 0)
    {   inst = MCore::BGENi;
	valu = 31 - CountLeadingZeros(n);
	return true;
    }
    if ((n & (n+1)) == 0)
    {   inst = MCore::BMASKi;
        valu = 32 - CountLeadingZeros(n);
	return true;
    }
    return false;
}

static bool
FindConst2(uint32_t n, unsigned &inst1, uint32_t &valu1,
		       unsigned &inst2, uint32_t &valu2)
{
    int i;
    uint32_t tmp;

    if (FindConst1(n, inst1, valu1))
    {   inst2 = 0;
	valu2 = 0;
	return true;
    }
    if (FindConst1(~n, inst1, valu1))
    {   inst2 = MCore::NOT;
	valu2 = 0;
	return true;
    }
    for (i = 1; i <= 32; i++)
    {   if (FindConst1(n-i, inst1, valu1))
	{   inst2 = MCore::ADDi;
	    valu2 = i;
	    return true;
	}
	if (FindConst1(n+i, inst1, valu1))
	{   inst2 = MCore::SUBi;
	    valu2 = i;
	    return true;
	}
	if (FindConst1(i - n, inst1, valu1))
	{   inst2 = MCore::RSUBi;
	    valu2 = i;
	    return true;
	}
    }
    for (i = 31, tmp = 0x80000000L; i >= 0; i--, tmp >>= 1)
    {   if (FindConst1(n & ~tmp, inst1, valu1))
	{   inst2 = MCore::BSETi;
	    valu2 = i;
	    return true;
	}
	if (FindConst1(n | tmp, inst1, valu1))
	{   inst2 = MCore::BCLRi;
	    valu2 = i;
	    return true;
	}
    }
    if ((n % 3) == 0 && FindConst1(n / 3, inst1, valu1))
    {	inst2 = MCore::IXH;
	valu2 = 0;
	return true;
    }
    if ((n % 5) == 0 && FindConst1(n / 5, inst1, valu1))
    {	inst2 = MCore::IXW;
	valu2 = 0;
	return true;
    }
    if ((n&1) == 0)		/* try shift left */
    {   tmp = n;
	i = 1;
	while ((n&1) == 0 && i < 32) {
	    n >>= 1;
	    if (FindConst1(n, inst1, valu1)) {
	        inst2 = MCore::LSLi;
		valu2 = i;
		return true;
	    }
	    i += 1;
	}
    }
    tmp = n;
    for (i = 1; i < 31; i++)	/* try rotate left */
    {   int c;
	c = tmp << 31;
	tmp >>= 1;
	tmp &= 0x7FFFFFFF;
	tmp |= c;   /* Simulate rotate.  */
	if (FindConst1(tmp, inst1, valu1))
	{   inst2 = MCore::ROTLi;
	    valu2 = i;
	    return true;
	}
    }
    return false;


}

bool MCoreDAGToDAGISel::tryConstant(SDNode *N) {
  ConstantSDNode *CN = cast<ConstantSDNode>(N);
  uint32_t n = CN->getZExtValue();
  unsigned inst1, inst2;
  uint32_t valu1, valu2;
  if (n <= 127)
    return false;	// let normal pattern take care of this
  if (FindConst2(n, inst1, valu1, inst2, valu2))
  {
    SDLoc dl(N);
    SDValue C = CurDAG->getTargetConstant(valu1, dl, MVT::i32);
    if (inst2 == 0) {
      CurDAG->SelectNodeTo(N, inst1, MVT::i32, C);
      return true;
    } else {
      SDNode *T = CurDAG->getMachineNode(inst1, dl, MVT::i32, C);
      switch (inst2)
      {
	case MCore::NOT:
	  CurDAG->SelectNodeTo(N, inst2, MVT::i32, SDValue(T, 0));
	  return true;
	case MCore::ADDi:
	case MCore::SUBi:
	case MCore::RSUBi:
	case MCore::BSETi:
	case MCore::BCLRi:
	case MCore::LSLi:
	case MCore::ROTLi:
	  C = CurDAG->getTargetConstant(valu2, dl, MVT::i32);
	  CurDAG->SelectNodeTo(N, inst2, MVT::i32, SDValue(T, 0), C);
	  return true;
	case MCore::IXH:
	case MCore::IXW:
	  CurDAG->SelectNodeTo(N, inst2, MVT::i32, SDValue(T, 0), SDValue(T, 0));
	  return true;
	default:
	  break;
      }
    }
  }
  return false;
}

bool MCoreDAGToDAGISel::trySEX(SDNode *N) {
  SDLoc dl(N);
  EVT NVT = N->getValueType(0);
  if (NVT == MVT::i32)
  { unsigned inst;
    EVT SVT = cast<VTSDNode>(N->getOperand(1))->getVT();
    if (SVT == MVT::i8)
	inst = MCore::SEXTB;
    else if (SVT == MVT::i16)
      inst = MCore::SEXTH;
    else
      return false;
    SDValue Ops[] = { N->getOperand(0) };
    CurDAG->SelectNodeTo(N, inst, MVT::i32, Ops);
    return true;
  }
  return false;
}

bool MCoreDAGToDAGISel::SelectAddCarry(SDNode *N) {
  MachineSDNode *NewNode = nullptr;
  auto Type0 = N->getValueType(0);
  auto Type1 = N->getValueType(1);
  auto Op0 = N->getOperand(0);
  auto Op1 = N->getOperand(1);
  auto Op2 = N->getOperand(2);
  SDLoc dl(N);

  if (isNullConstant(Op2)) {
    auto CA = CurDAG->getMachineNode(MCore::CLRC, dl, Type1);
    NewNode = CurDAG->getMachineNode(MCore::ADDC, dl, {Type0, Type1},
                                     {Op0, Op1, SDValue(CA, 0)});
  } else if (isOneConstant(Op2)) {
    auto CA = CurDAG->getMachineNode(MCore::SETC, dl, Type1);
    NewNode = CurDAG->getMachineNode(MCore::ADDC, dl, {Type0, Type1},
                                     {Op0, Op1, SDValue(CA, 0)});
  } else {
    NewNode = CurDAG->getMachineNode(MCore::ADDC, dl, {Type0, Type1},
                                     {Op0, Op1, Op2});
  }
  ReplaceNode(N, NewNode);
  return true;
}

bool MCoreDAGToDAGISel::SelectSubCarry(SDNode *N) {
  MachineSDNode *NewNode = nullptr;
  auto Type0 = N->getValueType(0);
  auto Type1 = N->getValueType(1);
  auto Op0 = N->getOperand(0);
  auto Op1 = N->getOperand(1);
  auto Op2 = N->getOperand(2);
  SDLoc dl(N);

  if (isNullConstant(Op2)) {
    auto CA = CurDAG->getMachineNode(MCore::SETC, dl, Type1);
    NewNode = CurDAG->getMachineNode(MCore::SUBC, dl, {Type0, Type1},
                                     {Op0, Op1, SDValue(CA, 0)});
  } else if (isOneConstant(Op2)) {
    auto CA = CurDAG->getMachineNode(MCore::CLRC, dl, Type1);
    NewNode = CurDAG->getMachineNode(MCore::SUBC, dl, {Type0, Type1},
                                     {Op0, Op1, SDValue(CA, 0)});
  } else {
    NewNode = CurDAG->getMachineNode(MCore::SUBC, dl, {Type0, Type1},
                                     {Op0, Op1, Op2});
  }
  ReplaceNode(N, NewNode);
  return true;
}

void MCoreDAGToDAGISel::Select(SDNode *N) {
LLVM_DEBUG(dbgs() << "MCoreDAGToDAGISel::Select " << N->getOperationName(CurDAG) << "\n");
  SDLoc dl(N);

  if (N->isMachineOpcode()) {
    N->setNodeId(-1);
    return;   // Already selected.
  }

  switch (N->getOpcode()) {
    case ISD::FrameIndex: {
      EVT VT = N->getValueType(0);
      SDValue Imm = CurDAG->getTargetConstant(0, dl, MVT::i32);
      int FI = cast<FrameIndexSDNode>(N)->getIndex();
      SDValue TFI = CurDAG->getTargetFrameIndex(FI, VT);
      ReplaceNode(N, CurDAG->getMachineNode(MCore::ADDi, dl, VT, TFI, Imm));
      return;
    }
    case ISD::Constant:
      if (tryConstant(N))
	return;
      break;
    case ISD::SIGN_EXTEND_INREG:	// don't know how to do this in *.td
      if (trySEX(N))
	return;
      break;
    case ISD::ADDCARRY:
      if (SelectAddCarry(N))
        return;
      break;
    case ISD::SUBCARRY:
      if (SelectSubCarry(N))
        return;
      break;
  }
  SelectCode(N);
}
